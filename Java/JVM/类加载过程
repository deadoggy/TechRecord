类加载过程：
  1.加载
  2.验证
  3.准备
  4.解析
  5.初始化
  6.使用
  7.卸载
其中 2 3 4 统一称作链接
加载 验证 准备 初始化 卸载 这5个阶段的顺序是固定的
解析可能在初始化之前，也有可能在初始化之后

1.加载
   加载分三个步骤：
    a) 根据一个类的全限定名来获取定义这个类的二进制字节流
    b) 将二进制所代表的静态存储结构转换为虚拟机方法区的运行时数据结构
    c) 在内存中生成一个 java.lang.Class 对象， 作为方法区这个类的各种数据的访问接口
   因为这三个步骤比较模糊，所以可以进行灵活处理。比如 a) 可以纵远端获取字节流
   以上情况只适合非数组类的创建。因为数组类是通过Java虚拟机进行创建的，并非类加载器。因此数组类加载符合一下规则:
    a) 数组的组件是引用类型，则递归的使用上面的方法进行类加载。数组会在加载数组组件的类加载器的名称空间上被表示。
    b) 如果组件不是引用类型 (int)， 则Java虚拟机会把数组标记为与引导类加载器相关联。
    c) 数组类的可见性与其组件的可见性一致，如果组件不是引用类型，则默认为public
   加载完成后，虚拟机外部的二进制字节流就按照虚拟机需要的格式存储在虚拟机的方法区内。

2.验证
   大体四个阶段： 文件格式验证， 元数据验证， 字节码验证， 引用符号验证
   a) 字节码验证：
    魔数： 0xCAFEBABE
    主次版本号
    常量tag标志， 从而检查是否有不支持的常量
    指向常量的各种索引值中是否有不存在的或者不支持的常量
    是否有不支持UTF8编码的常量
    ...
   b) 元数据验证：
    对字节码描述的信息进行语义分析，检查是否符合java语言规范的要求。
    是否有父类（除了java.lang,Object之外都有父类）
    是否继承了不允许被继承的类
    对非抽象类检查是否所有要求实现的方法都被实现了
    是否有字段与父类产生了矛盾
   c) 字节码验证：
    最复杂的步骤，检查程序的语义是否符合规范和逻辑
   d) 符号引用验证：
    对类自身意外的信息进行匹配性验证（常量池中）

3.准备
   为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都将在方法区内分配。 注意是类变量不是实例变量。
   一般初始值是类型0值。 但如果类字段的字段属性表中有ConstantValue值，则会直接初始化为ConstantValue所指定的初始值;
   例如 public static final int a = 123;
   a在这个阶段会被初始化为123而不是0;

4.解析
     符号引用   ----->  直接引用
   (任意字面量)         (指针，偏移量，句柄...)
   对一个符号引用进行多次解析请求是很常见的。
   步骤（JVM P221）
   类&借口， 字段， 类方法， 接口方法

5.类初始化：
   根据程序员主观的设计去初始化类变量和其他资源。另一个角度就是类加载器执行<clinit>()方法的过程。
   <clinit>（）方法是由编译器自动收集类中所有变量的赋值动作和静态语句块( static{} )中的语句合并
   产生的，编译器手机的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在语句块
   之前的变量，之后的变量可以赋值，不能访问;

   public class Test{
        static{
            i = 0;                   //正常编译通过
            System.out.println(i);   //编译器会提示非法向前引用
        }

        static int i =1;
   }

  由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块优于子类的赋值操作。
  <clinit>() 方法对于类或者接口来说不是必须的，如果一个类中没有静态语句块，也没有对
  变量的赋值操作，那么编译器可以不生成<clinit>()方法。
  对于接口，只有父类的变量需要使用时才会执行父接口的初始化。
  接口的实现类在初始化时也不会执行接口的<clinit>()方法。
  虚拟机会保证一个类的<clinit>()方法在多线程环境中正确的枷锁，同步。当一个线程的<clinit>()
  阻塞退出后，其他线程不会再执行<clinit>()方法。


类加载器：
  对于任意一个Java类，需要通过类加载器和类本身共同确定这个类在虚拟机中的唯一性，每一个类加载器，都有一个唯一的
类命名空间。即如果两个类来源于同一个class文件，被同一个虚拟机加载，但是由不同的类加载器加载，这两个类也是不相同的。
  从Java虚拟机的角度讲只有两种类加载器：启动类加载器 和 其他类加载器。前者是虚拟机的一部分， 后者独立于虚拟机，
并且都是java.lang.CLassLoader的派生类;
  从Java程序员的角度说，可以划分的再细致，大体上都有一下三类：
  1.启动类加载器：负责将存放在<JAVA_HOME>/lib路径下的并且被虚拟机识别的类加载进内存，且仅按照文件名进行加载(rt.jar);
因此即使把自己的类放入<JAVA_HOME>/lib也无法加载，该加载器无法在Java语言中被引用;
  2.扩展类加载器：由 sum.misc.Launcher$ExtClassLoader实现，负责加载 <JAVA_HOME>/lib/ext路径下的， 或者被
java.ext.dirs所指定的路径下的所有类库，开发者可以直接使用扩展类加载器;
  3.应用程序类加载器： 是由sun.misc,Launcher$AppClassLoader实现的。由于该类加载器是getSystemClassLoader()方法的
返回值，所以也叫做系统类加载器。负责加载用户类路径(ClassPath)上所指定的类库。如果开发者没有定义自己的类加载器，一般情况下
这就是默认的类加载器。


双亲委派模型：
  这些类加载器的关系如下所示:
           启动类加载器 <------扩展类加载器<-------系统类加载器<----------自定义类加载器
                                                   ^----------------自定义类加载器
  双亲委派模型要求除了顶层的类加载器之外，其余类加载器都要有自己的父类加载器。这里加载器之间的父子关系一般不会以继承的方式实现，
  一般会以组合的方式实现。
  工作过程：
    每次类加载器受到加载类的请求时，会首先把请求传递到父类加载器中。因此所有类加载请求都会被传递到顶层的启动类加载器中。只有当
    父类不能完成类加载时，子类才会尝试自己加载。
  保证同一个类被同一个加载器所加载，从而保证类的唯一性。
  
