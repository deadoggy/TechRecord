类加载过程：
  1.加载
  2.验证
  3.准备
  4.解析
  5.初始化
  6.使用
  7.卸载
其中 2 3 4 统一称作链接
加载 验证 准备 初始化 卸载 这5个阶段的顺序是固定的
解析可能在初始化之前，也有可能在初始化之后

1.加载
   加载分三个步骤：
    a) 根据一个类的全限定名来获取定义这个类的二进制字节流
    b) 将二进制所代表的静态存储结构转换为虚拟机方法区的运行时数据结构
    c) 在内存中生成一个 java.lang.Class 对象， 作为方法区这个类的各种数据的访问接口
   因为这三个步骤比较模糊，所以可以进行灵活处理。比如 a) 可以纵远端获取字节流
   以上情况只适合非数组类的创建。因为数组类是通过Java虚拟机进行创建的，并非类加载器。因此数组类加载符合一下规则:
    a) 数组的组件是引用类型，则递归的使用上面的方法进行类加载。数组会在加载数组组件的类加载器的名称空间上被表示。
    b) 如果组件不是引用类型 (int)， 则Java虚拟机会把数组标记为与引导类加载器相关联。
    c) 数组类的可见性与其组件的可见性一致，如果组件不是引用类型，则默认为public
   加载完成后，虚拟机外部的二进制字节流就按照虚拟机需要的格式存储在虚拟机的方法区内。

2.验证
   大体四个阶段： 文件格式验证， 元数据验证， 字节码验证， 引用符号验证
   a) 字节码验证：
    魔数： 0xCAFEBABE
    主次版本号
    常量tag标志， 从而检查是否有不支持的常量
    指向常量的各种索引值中是否有不存在的或者不支持的常量
    是否有不支持UTF8编码的常量
    ...
   b) 元数据验证：
    对字节码描述的信息进行语义分析，检查是否符合java语言规范的要求。
    是否有父类（除了java.lang,Object之外都有父类）
    是否继承了不允许被继承的类
    对非抽象类检查是否所有要求实现的方法都被实现了
    是否有字段与父类产生了矛盾
   c) 字节码验证：
    最复杂的步骤，检查程序的语义是否符合规范和逻辑
   d) 符号引用验证：
    对类自身意外的信息进行匹配性验证（常量池中）

3.准备
   为类变量分配内存并设置类变量的初始值，这些变量所使用的内存都将在方法区内分配。 注意是类变量不是实例变量。
   一般初始值是类型0值。 但如果类字段的字段属性表中有ConstantValue值，则会直接初始化为ConstantValue所指定的初始值;
   例如 public static final int a = 123;
   a在这个阶段会被初始化为123而不是0;

4.解析
     符号引用   ----->  直接引用
   (任意字面量)         (指针，偏移量，句柄...)
   对一个符号引用进行多次解析请求是很常见的。
   步骤（JVM P221）
   类&借口， 字段， 类方法， 接口方法

5.类初始化：
   根据程序员主观的设计去初始化类变量和其他资源。另一个角度就是类加载器执行<clinit>()方法的过程。
   <clinit>（）方法是由编译器自动收集类中所有变量的赋值动作和静态语句块( static{} )中的语句合并
   产生的，编译器手机的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在语句块
   之前的变量，之后的变量可以赋值，不能访问;

   public class Test{
        static{
            i = 0;                   //正常编译通过
            System.out.println(i);   //编译器会提示非法向前引用
        }

        static int i =1;
   }

  由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块优于子类的赋值操作。
  <clinit>() 方法对于类或者接口来说不是必须的，如果一个类中没有静态语句块，也没有对
  变量的赋值操作，那么编译器可以不生成<clinit>()方法。
  对于接口，只有父类的变量需要使用时才会执行父接口的初始化。
  接口的实现类在初始化时也不会执行接口的<clinit>()方法。
  虚拟机会保证一个类的<clinit>()方法在多线程环境中正确的枷锁，同步。当一个线程的<clinit>()
  阻塞退出后，其他线程不会再执行<clinit>()方法。
